#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

#pragma kernel CapsuleOcclusion

// TODO: Once we upgrade, we will get multi_compile support in compute shaders, and these variants will be nicer:
// #pragma multi_compile _ MONTE_CARLO
// #pragma multi_compile _ AMBIENT_OCCLUSION
// #pragma multi_compile _ SPECULAR_OCCLUSION
// #pragma multi_compile _ DIRECTIONAL_SHADOW

// Codegen'd all these kernel permutations with:
// var res = "";
// for (var i = 0; i < 16; ++i)
// {
//     var monteCarlo = (i & (1 << 0));
//     var ambientOcclusion = (i & (1 << 1));
//     var specularOcclusion = (i & (1 << 2));
//     var directionalShadows = (i & (1 << 3));
//     res += "#pragma kernel ";
//     res += "CapsuleOcclusion_MC_" + (monteCarlo ? "ON_" : "OFF");
//     res += "_AO_" + (ambientOcclusion ? "ON_" : "OFF");
//     res += "_SO_" + (specularOcclusion ? "ON_" : "OFF");
//     res += "_DS_" + (directionalShadows ? "ON_" : "OFF");

//     res += " CapsuleOcclusion=";
//     res += "CapsuleOcclusion_MC_" + (monteCarlo ? "ON_" : "OFF");
//     res += "_AO_" + (ambientOcclusion ? "ON_" : "OFF");
//     res += "_SO_" + (specularOcclusion ? "ON_" : "OFF");
//     res += "_DS_" + (directionalShadows ? "ON_" : "OFF");

//     res += " ";

//     if (monteCarlo) { res += "MONTE_CARLO "; }
//     if (ambientOcclusion) { res += "AMBIENT_OCCLUSION "; }
//     if (specularOcclusion) { res += "SPECULAR_OCCLUSION "; }
//     if (directionalShadows) { res += "DIRECTIONAL_SHADOW "; }
//     res += "\n";
// }
// console.log(res);

#pragma kernel CapsuleOcclusion_MC_OFF_AO_OFF_SO_OFF_DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_OFF_SO_OFF_DS_OFF 
#pragma kernel CapsuleOcclusion_MC_ON__AO_OFF_SO_OFF_DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_OFF_SO_OFF_DS_OFF MONTE_CARLO 
#pragma kernel CapsuleOcclusion_MC_OFF_AO_ON__SO_OFF_DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_ON__SO_OFF_DS_OFF AMBIENT_OCCLUSION 
#pragma kernel CapsuleOcclusion_MC_ON__AO_ON__SO_OFF_DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_ON__SO_OFF_DS_OFF MONTE_CARLO AMBIENT_OCCLUSION 
#pragma kernel CapsuleOcclusion_MC_OFF_AO_OFF_SO_ON__DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_OFF_SO_ON__DS_OFF SPECULAR_OCCLUSION 
#pragma kernel CapsuleOcclusion_MC_ON__AO_OFF_SO_ON__DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_OFF_SO_ON__DS_OFF MONTE_CARLO SPECULAR_OCCLUSION 
#pragma kernel CapsuleOcclusion_MC_OFF_AO_ON__SO_ON__DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_ON__SO_ON__DS_OFF AMBIENT_OCCLUSION SPECULAR_OCCLUSION 
#pragma kernel CapsuleOcclusion_MC_ON__AO_ON__SO_ON__DS_OFF CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_ON__SO_ON__DS_OFF MONTE_CARLO AMBIENT_OCCLUSION SPECULAR_OCCLUSION 
#pragma kernel CapsuleOcclusion_MC_OFF_AO_OFF_SO_OFF_DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_OFF_SO_OFF_DS_ON_ DIRECTIONAL_SHADOW 
#pragma kernel CapsuleOcclusion_MC_ON__AO_OFF_SO_OFF_DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_OFF_SO_OFF_DS_ON_ MONTE_CARLO DIRECTIONAL_SHADOW 
#pragma kernel CapsuleOcclusion_MC_OFF_AO_ON__SO_OFF_DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_ON__SO_OFF_DS_ON_ AMBIENT_OCCLUSION DIRECTIONAL_SHADOW 
#pragma kernel CapsuleOcclusion_MC_ON__AO_ON__SO_OFF_DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_ON__SO_OFF_DS_ON_ MONTE_CARLO AMBIENT_OCCLUSION DIRECTIONAL_SHADOW 
#pragma kernel CapsuleOcclusion_MC_OFF_AO_OFF_SO_ON__DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_OFF_SO_ON__DS_ON_ SPECULAR_OCCLUSION DIRECTIONAL_SHADOW 
#pragma kernel CapsuleOcclusion_MC_ON__AO_OFF_SO_ON__DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_OFF_SO_ON__DS_ON_ MONTE_CARLO SPECULAR_OCCLUSION DIRECTIONAL_SHADOW 
#pragma kernel CapsuleOcclusion_MC_OFF_AO_ON__SO_ON__DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_OFF_AO_ON__SO_ON__DS_ON_ AMBIENT_OCCLUSION SPECULAR_OCCLUSION DIRECTIONAL_SHADOW 
#pragma kernel CapsuleOcclusion_MC_ON__AO_ON__SO_ON__DS_ON_ CapsuleOcclusion=CapsuleOcclusion_MC_ON__AO_ON__SO_ON__DS_ON_ MONTE_CARLO AMBIENT_OCCLUSION SPECULAR_OCCLUSION DIRECTIONAL_SHADOW 

RW_TEXTURE2D_X(float, _OcclusionTexture);   // AO texture. 
RW_TEXTURE2D_X(unorm float2, _CapsuleOcclusions);   // R: Specular Occlusion G: Shadow.  8bit UNorm per channel.

#ifdef MONTE_CARLO
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#endif

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/BSDF.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/CapsuleShadows/Shaders/CapsuleOcclusionCommon.hlsl"

// --------------------------------------------
// Options
// --------------------------------------------
// IMPORTANT TODO: For now assume we run at full res, whenever we need to run in half res we need a different way to select the right tile, for now it is assumed that we have
// a thread/pixel 1-by-1 mapping.
// Also, please note that for half resolution the ambient occlusion needs to work differently, we need place the data in the pre-upscale AO data which is differently format (ready for upscale). 

// All in all to run in half res a non-trivial amount of small fixes are needed, but we'll need that.

// #define HALF_RES 0 


[numthreads(16, 16, 1)]
void CapsuleOcclusion(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    uint2 pixelCoord = dispatchThreadId.xy;
    uint2 tileCoord = groupId;

    float depth = LoadCameraDepth(pixelCoord.xy);

    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, tileCoord);

    float ao = 1.0f;
    float specOcclusion = 1;
    float shadow = 1;

    uint capsuleFeatureFlags = 0;
#ifdef AMBIENT_OCCLUSION
    capsuleFeatureFlags = capsuleFeatureFlags | CAPSULEOCCLUSIONTYPE_AMBIENT_OCCLUSION;
#endif
#ifdef SPECULAR_OCCLUSION
    capsuleFeatureFlags = capsuleFeatureFlags | CAPSULEOCCLUSIONTYPE_SPECULAR_OCCLUSION;
#endif
#ifdef DIRECTIONAL_SHADOW
    capsuleFeatureFlags = capsuleFeatureFlags | CAPSULEOCCLUSIONTYPE_DIRECTIONAL_SHADOWS;
#endif

    if ((capsuleFeatureFlags != 0)
        && (posInput.deviceDepth > 0.0f))
    {
        NormalData normalData;
        const float4 normalBuffer = LOAD_TEXTURE2D_X(_NormalBufferTexture, pixelCoord);
        DecodeFromNormalBuffer(normalBuffer, pixelCoord, normalData);

        float3 V = GetWorldSpaceNormalizeViewDir(posInput.positionWS);

    #ifdef MONTE_CARLO
        EvaluateCapsuleOcclusionMonteCarlo(
            capsuleFeatureFlags,
            posInput,
            normalData.normalWS,
            V,
            max(0.04f, PerceptualRoughnessToRoughness(normalData.perceptualRoughness)),
            ao,
            specOcclusion,
            shadow
        );
    #else
        EvaluateCapsuleOcclusion(capsuleFeatureFlags,
            posInput,
            normalData.normalWS,
            V,
            max(0.04f, PerceptualRoughnessToRoughness(normalData.perceptualRoughness)),
            ao,
            specOcclusion,
            shadow
        );
    #endif
    }

#ifdef AMBIENT_OCCLUSION
    _OcclusionTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = 1.0f - ((1.0f - _OcclusionTexture[COORD_TEXTURE2D_X(pixelCoord.xy)]) * ao);
#endif

#if defined(SPECULAR_OCCLUSION) || defined(DIRECTIONAL_SHADOW)
    _CapsuleOcclusions[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float2(specOcclusion, lerp(1, shadow, _CapsuleShadowIntensity));
#endif


}
